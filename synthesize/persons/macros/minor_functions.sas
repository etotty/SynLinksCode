

*** macro that makes every letter in a character string lower case;
%macro standardize_varname(invarname,outvarname,in_macro_flag);
  %local invarname outvarname in_macro_flag;
  %if &in_macro_flag.=1 %then %do;
    &outvarname.=compress("&invarname.");
  %end;
  %else %do;
    &outvarname.=compress(&invarname.);
  %end;
  _lcletters_="abcdefghijklmnopqrstuvwxyz";
  _ucletters_="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  do _i_=1 to length(&outvarname.);
    do _j_=1 to 26;
      if substr(&outvarname.,_i_,1)=substr(_ucletters_,_j_,1)
      then substr(&outvarname.,_i_,1)=substr(_lcletters_,_j_,1);
    end;
  end;
%mend;


*** macro that uses metadata to get list of variables needed for the modeling of
  &curvar. as well as list of variables being modeled simultaneously with &curvar..;
%macro model_varlists;
  %local i s nx;
  %global num_inputs num_outputs input_vars output_vars nlists regressors transform_list interaction_list;
  %let num_inputs=0;
  %let num_outputs=0;
  %let nlists=0;
  data imp_inputs&m. (keep=check_name check_type check_list check_transform) imp_outputs&m. (keep=check_name);
    set metadata.all_vars_referenced (where=(varname="&curvar." and check_name ne "&curvar."));
    if check_type in (1,2,4,5,7,8) then output imp_inputs&m.;
    else if check_type in (3,6) then output imp_outputs&m.;
  run;
  proc sort data=imp_inputs&m.;
    by check_name check_type;
  run;
  proc sort data=imp_outputs&m.;
    by check_name;
  run;
  *** put the inputs and outputs into local macro variables;
  data tempin&m. (drop=_counter_ _nlists_);
    set imp_inputs&m. (where=(check_type ~in (7,8))) end=lastobs;
    by check_name;
    retain _counter_ 0;
    retain _nlists_ 0;
    _nlists_=max(_nlists_,check_list);
    if last.check_name then do;
      _counter_=_counter_+1;
      output;
    end;
    if lastobs then call symput("num_inputs",compress(put(_counter_,12.)));
    if lastobs then call symput("nlists",compress(put(_nlists_,12.)));
  run;
  %do i=1 %to &num_inputs.;
    %local input_var&i.;
  %end;
  data _null_;
    set tempin&m.;
    call symput("input_var" || compress(put(_n_,12.)),compress(check_name));
  run;
  data tempout&m. (drop=_counter_);
    set imp_outputs&m. end=lastobs;
    by check_name;
    retain _counter_ 0;
    if last.check_name then do;
      _counter_=_counter_+1;
      output;
    end;
    if lastobs then call symput("num_outputs",compress(put(_counter_,12.)));
  run;
  %do i=1 %to &num_outputs.;
    %local output_var&i.;
  %end;
  data _null_;
    set tempout&m.;
    call symput("output_var" || compress(put(_n_,12.)),compress(check_name));
  run;
  proc datasets lib=work nolist;
    delete tempin&m.;
    delete tempout&m.;
  run;
  *** Now make lists for keep statements;
  %let input_vars=;
  %let output_vars=;
  %do i=1 %to &num_inputs.;
    %let input_vars=&input_vars. &&input_var&i..;
    %if &i.<%eval(&num_outputs.+1) %then %let output_vars=&output_vars. &&output_var&i..;
  %end;
  %if &num_outputs.>&num_inputs. %then %do; 
    %do i=%eval(&num_inputs.+1) %to &num_outputs.;
      %let output_vars=&output_vars. &&output_var&i..;
    %end;
  %end;
  *** Now check to see if any variables were specified in vardefs to constrain the imputation of &curvar.;
  %global min_imp_var max_imp_var;
  %let min_imp_var=;
  %let max_imp_var=;
  data _null_;
    set imp_inputs&m. (where=(check_type in (7,8)));
    if check_type=7 then call symput("min_imp_var",compress(check_name));
    if check_type=8 then call symput("max_imp_var",compress(check_name));
  run;
  *** Now build lists of stratifiers and regressors;
  %do s=1 %to &nlists.;
    %local ns&s.;
    %global stratifiers&s.;
    %let ns&s.=0;
    %let stratifiers&s.=;
  %end;
  %let regressors=;
  %let transform_list=;
  %let nx=0;
  *** insure no duplicates;
  proc sort data=imp_inputs&m. (where=(check_type in (4,5)));
    by check_type check_list check_name;
  run;
  data imp_inputs&m.;
    set imp_inputs&m.;
    by check_type check_list check_name;
    if last.check_name then output;
  run;
  *** get counts of vars in lists;
  proc freq data=imp_inputs&m. (where=(check_type in (4,5))) noprint;
    tables check_type*check_list /missing out=intable&m.;
  run;
  data _null_;
    set intable&m.;
    %do s=1 %to &nlists.;
      if check_type=4 and check_list=&s. then call symput("ns&s.",compress(put(count,12.)));
    %end;
    if check_type=5 then call symput("nx",compress(put(count,12.)));
  run;
  *** put variable names from metadata into local macro variables;
  %do s=1 %to &nlists.;
    %do i=1 %to &&ns&s..;
      %local svar&s._&i.;
    %end;
  %end;
  %do i=1 %to &nx.;
    %local xvar&i. tflag&i.;
  %end;
  data _null_;
    set imp_inputs&m. end=lastobs;
    by check_type check_list;
    retain _count_ 0;
    if first.check_list then _count_=0;
    _count_=_count_+1;
    if check_type=4 then call symput("svar" ||
      compress(put(check_list,12.)) || "_" ||
      compress(put(_count_,12.)),compress(check_name));
    else if check_type=5 then do;
      call symput("xvar" || compress(put(_count_,12.)),compress(check_name));
      call symput("tflag" || compress(put(_count_,12.)),compress(check_transform));
    end;
  run;
  *** now build global macro lists;
  %do s=1 %to &nlists.;
    %do i=1 %to &&ns&s..;
      %let stratifiers&s.=&&stratifiers&s. &&svar&s._&i..;
    %end;
    %if "&&stratifiers&s.."="" %then %let stratifiers&s.=_constant_;
  %end;
  %do i=1 %to &nx.;
    %let regressors=&regressors. &&xvar&i..;
    %if &&tflag&i..=1 %then %let transform_list=&transform_list. &&xvar&i..;
  %end;
  %if "&regressors."="" %then %let regressors=_constant_;
  *** interaction list;
  %local num_interactions;
  %let num_interactions=0;
  data _null_;
    set metadata.interactions (where=(varname="&curvar."));
    retain count 0;
    count=count+1;
    call symput("num_interactions",compress(put(count,8.)));
  run;
  %if &num_interactions.>0 %then %do;
    %do i=1 %to &num_interactions.;
      %local interaction&i.;
    %end;
    data _null_;
      set metadata.interactions (where=(varname="&curvar."));
      retain count 0;
      count=count+1;
      call symput("interaction" || compress(put(count,8.)),interaction_term);
    run;
    %let interaction_list=;
    %do i=1 %to &num_interactions.;
      %let interaction_list=&interaction_list. &&interaction&i..;
    %end;
  %end;
%mend;


